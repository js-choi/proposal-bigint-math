<pre class=metadata>
title: ES BigInt Math (2021)
status: proposal
stage: 0
location: https://github.com/js-choi/proposal-bigint-math
copyright: false
contributors: J.Â S. Choi
</pre>
<script src=ecmarkup.js defer></script>
<link rel=stylesheet href=ecmarkup.css>

<emu-intro id=introduction>
  <h1>Introduction</h1>
  <p>This is the formal specification for a proposed extension
  of the `Math` JavaScript global object with BigInt operations.
  It modifies the original <a
  href=https://tc39.github.io/ecma262/>ECMAScript specification</a> with
  several new or revised clauses. See <a
  href=https://github.com/js-choi/proposal-bigint-math/blob/main/README.md>the proposal's
  explainer</a> for the proposal's background, motivation, and usage examples.</p>
</emu-intro>

<emu-clause id="sec-ecmascript-data-types-and-values" aoid="Type">
  <h1>ECMAScript Data Types and Values</h1>

  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript Language Types</h1>

    <emu-clause id="sec-numeric-types">
      <h1>Numeric Types</h1>

      <emu-note type=editor>
        <p>This section augments the <a
        href=https://tc39.es/ecma262/#sec-numeric-types>original
        Numeric Types clause</a>.</p>
      </emu-note>

      <p>ECMAScript has two built-in numeric types: Number and BigInt. In this specification, every numeric type _T_ contains a multiplicative identity value denoted _T_::unit. The specification types also have the following abstract operations, likewise denoted _T_::<i>op</i> for a given operation with specification name <i>op</i>. All argument types are _T_. The "Result" column shows the return type, along with an indication if it is possible for some invocations of the operation to return an abrupt completion.</p>
      <emu-table id="table-numeric-type-ops" caption="Numeric Type Operations">
        <table>
          <tbody>
          <tr>
            <th>
              Invocation Synopsis
            </th>
            <th>
              Example source
            </th>
            <th>
              Invoked by the Evaluation semantics of ...
            </th>
            <th>
              Result
            </th>
          </tr>

          <tr>
            <td>
              _T_::bitwiseOR(x,&nbsp;y)
            </td>
            <td>
              `x&nbsp;|&nbsp;y`
            </td>
            <td>
              <emu-xref href="#sec-binary-bitwise-operators" title></emu-xref>
            </td>
            <td>
              _T_
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::abs(x)</ins>
            </td>
            <td>
              <ins>`Math.abs(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.abs" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::acosh(x)</ins>
            </td>
            <td>
              <ins>`Math.acosh(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.acosh" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::asinh(x)</ins>
            </td>
            <td>
              <ins>`Math.asinh(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.asinh" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::atanh(x)</ins>
            </td>
            <td>
              <ins>`Math.atanh(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.atanh" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::ceil(x)</ins>
            </td>
            <td>
              <ins>`Math.ceil(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.ceil" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::cosh(x)</ins>
            </td>
            <td>
              <ins>`Math.cosh(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.cosh" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::cbrt(x)</ins>
            </td>
            <td>
              <ins>`Math.cbrt(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.cbrt" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::exp(x)</ins>
            </td>
            <td>
              <ins>`Math.exp(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.exp" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::expm1(x)</ins>
            </td>
            <td>
              <ins>`Math.expm1(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.expm1" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::floor(x)</ins>
            </td>
            <td>
              <ins>`Math.floor(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.floor" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::hypot(x)</ins>
            </td>
            <td>
              <ins>`Math.hypot(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.hypot" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::log(x)</ins>
            </td>
            <td>
              <ins>`Math.log(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.log" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::log1p(x)</ins>
            </td>
            <td>
              <ins>`Math.log1p(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.log1p" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::log10(x)</ins>
            </td>
            <td>
              <ins>`Math.log10(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.log10" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::log2(x)</ins>
            </td>
            <td>
              <ins>`Math.log2(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.log2" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::min(x)</ins>
            </td>
            <td>
              <ins>`Math.min(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.min" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::pow(x)</ins>
            </td>
            <td>
              <ins>`Math.pow(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.pow" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::round(x)</ins>
            </td>
            <td>
              <ins>`Math.round(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.round" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::sign(x)</ins>
            </td>
            <td>
              <ins>`Math.sign(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.sign" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::sinh(x)</ins>
            </td>
            <td>
              <ins>`Math.sinh(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.sinh" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::sqrt(x)</ins>
            </td>
            <td>
              <ins>`Math.sqrt(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.sqrt" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::tanh(x)</ins>
            </td>
            <td>
              <ins>`Math.tanh(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.tanh" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::trunc(x)</ins>
            </td>
            <td>
              <ins>`Math.trunc(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.trunc" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>


          <tr>
            <td>
              _T_::toString(x)
            </td>
            <td>
              `String(x)`
            </td>
            <td>
              Many expressions and built-in functions, via <emu-xref href="#sec-tostring" title></emu-xref>
            </td>
            <td>
              String
            </td>

          </tr>
          </tbody>
        </table>
      </emu-table>

      <emu-clause id="sec-ecmascript-language-types-number-type">
        <h1>The Number Type</h1>

        <ins class="block">
          <emu-clause id="sec-numeric-types-number-abs" type="numeric method">
            <h1>
              Number::abs (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, return *NaN*.
              1. If _x_ is *-0*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
              1. If _x_ is *-&infin;*<sub>ð½</sub>, return *+&infin;*<sub>ð½</sub>.
              1. If _x_ &lt; *+0*<sub>ð½</sub>, return -_x_.
              1. Return _x_.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-acosh" type="numeric method">
            <h1>
              Number::acosh (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN* or _x_ is *+&infin;*<sub>ð½</sub>, return _x_.
              1. If _x_ is *1*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
              1. If _x_ &lt; *1*<sub>ð½</sub>, return *NaN*.
              1. Return an implementation-approximated value representing the result of the inverse hyperbolic cosine of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-asinh" type="numeric method">
            <h1>
              Number::asinh (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>ð½</sub>, _x_ is *-0*<sub>ð½</sub>, _x_ is *+&infin;*<sub>ð½</sub>, or _x_ is *-&infin;*<sub>ð½</sub>, return _x_.
              1. Return an implementation-approximated value representing the result of the inverse hyperbolic sine of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-atanh" type="numeric method">
            <h1>
              Number::atanh (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>ð½</sub>, or _x_ is *-0*<sub>ð½</sub>, return _x_.
              1. If _x_ &gt; *1*<sub>ð½</sub> or _x_ &lt; *-1*<sub>ð½</sub>, return *NaN*.
              1. If _x_ is *1*<sub>ð½</sub>, return *+&infin;*<sub>ð½</sub>.
              1. If _x_ is *-1*<sub>ð½</sub>, return *-&infin;*<sub>ð½</sub>.
              1. Return an implementation-approximated value representing the result of the inverse hyperbolic tangent of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-ceil" type="numeric method">
            <h1>
              Number::ceil (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>ð½</sub>, _x_ is *-0*<sub>ð½</sub>, _x_ is *+&infin;*<sub>ð½</sub>, or _x_ is *-&infin;*<sub>ð½</sub>, return _x_.
              1. If _x_ &lt; *+0*<sub>ð½</sub> and _x_ &gt; *-1*<sub>ð½</sub>, return *-0*<sub>ð½</sub>.
              1. If _x_ is an integral Number, return _x_.
              1. Return the smallest (closest to -&infin;) integral Number value that is not less than _x_.
            </emu-alg>
            <emu-note>
              <p>The value of `Math.ceil(x)` is the same as the value of `-Math.floor(-x)`.</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-cosh" type="numeric method">
            <h1>
              Number::cosh (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+&infin;*<sub>ð½</sub>, or _x_ is *-&infin;*<sub>ð½</sub>, return _x_.
              1. If _x_ is *+0*<sub>ð½</sub> or _x_ is *-0*<sub>ð½</sub>, return *1*<sub>ð½</sub>.
              1. Return an implementation-approximated value representing the result of the hyperbolic cosine of â(_x_).
            </emu-alg>

            <emu-note>
              <p>The value of `Math.cosh(x)` is the same as the value of `(Math.exp(x) + Math.exp(-x)) / 2`.</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-cbrt" type="numeric method">
            <h1>
              Number::cbrt (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>ð½</sub>, _x_ is *-0*<sub>ð½</sub>, _x_ is *+&infin;*<sub>ð½</sub>, or _x_ is *-&infin;*<sub>ð½</sub>, return _x_.
              1. Return an implementation-approximated value representing the result of the cube root of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-exp" type="numeric method">
            <h1>
              Number::exp (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN* or _x_ is *+&infin;*<sub>ð½</sub>, return _x_.
              1. If _x_ is *+0*<sub>ð½</sub> or _x_ is *-0*<sub>ð½</sub>, return *1*<sub>ð½</sub>.
              1. If _x_ is *-&infin;*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
              1. Return an implementation-approximated value representing the result of the exponential function of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-expm1" type="numeric method">
            <h1>
              Number::expm1 (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>ð½</sub>, _x_ is *-0*<sub>ð½</sub>, or _x_ is *+&infin;*<sub>ð½</sub>, return _x_.
              1. If _x_ is *-&infin;*<sub>ð½</sub>, return *-1*<sub>ð½</sub>.
              1. Return an implementation-approximated value representing the result of subtracting 1 from the exponential function of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-floor" type="numeric method">
            <h1>
              Number::floor (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>ð½</sub>, _x_ is *-0*<sub>ð½</sub>, _x_ is *+&infin;*<sub>ð½</sub>, or _x_ is *-&infin;*<sub>ð½</sub>, return _x_.
              1. If _x_ &lt; *1*<sub>ð½</sub> and _x_ &gt; *+0*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
              1. If _x_ is an integral Number, return _x_.
              1. Return the greatest (closest to +&infin;) integral Number value that is not greater than _x_.
            </emu-alg>
            <emu-note>
              <p>The value of `Math.floor(x)` is the same as the value of `-Math.ceil(-x)`.</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-log" type="numeric method">
            <h1>
              Number::log (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN* or _x_ is *+&infin;*<sub>ð½</sub>, return _x_.
              1. If _x_ is *1*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
              1. If _x_ is *+0*<sub>ð½</sub> or _x_ is *-0*<sub>ð½</sub>, return *-&infin;*<sub>ð½</sub>.
              1. If _x_ &lt; *+0*<sub>ð½</sub>, return *NaN*.
              1. Return an implementation-approximated value representing the result of the natural logarithm of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-log1p" type="numeric method">
            <h1>
              Number::log1p (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>ð½</sub>, _x_ is *-0*<sub>ð½</sub>, or _x_ is *+&infin;*<sub>ð½</sub>, return _x_.
              1. If _x_ is *-1*<sub>ð½</sub>, return *-&infin;*<sub>ð½</sub>.
              1. If _x_ &lt; *-1*<sub>ð½</sub>, return *NaN*.
              1. Return an implementation-approximated value representing the result of the natural logarithm of 1 + â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-log10" type="numeric method">
            <h1>
              Number::log10 (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN* or _x_ is *+&infin;*<sub>ð½</sub>, return _x_.
              1. If _x_ is *1*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
              1. If _x_ is *+0*<sub>ð½</sub> or _x_ is *-0*<sub>ð½</sub>, return *-&infin;*<sub>ð½</sub>.
              1. If _x_ &lt; *+0*<sub>ð½</sub>, return *NaN*.
              1. Return an implementation-approximated value representing the result of the base 10 logarithm of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-log2" type="numeric method">
            <h1>
              Number::log2 (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN* or _x_ is *+&infin;*<sub>ð½</sub>, return _x_.
              1. If _x_ is *1*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
              1. If _x_ is *+0*<sub>ð½</sub> or _x_ is *-0*<sub>ð½</sub>, return *-&infin;*<sub>ð½</sub>.
              1. If _x_ &lt; *+0*<sub>ð½</sub>, return *NaN*.
              1. Return an implementation-approximated value representing the result of the base 2 logarithm of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-round" type="numeric method">
            <h1>
              Number::round (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, *+&infin;*<sub>ð½</sub>, *-&infin;*<sub>ð½</sub>, or an integral Number, return _x_.
              1. If _x_ &lt; *0.5*<sub>ð½</sub> and _x_ &gt; *+0*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
              1. If _x_ &lt; *+0*<sub>ð½</sub> and _x_ &ge; *-0.5*<sub>ð½</sub>, return *-0*<sub>ð½</sub>.
              1. Return the integral Number closest to _x_, preferring the Number closer to +&infin; in the case of a tie.
            </emu-alg>
            <emu-note>
              <p>`Math.round(3.5)` returns 4, but `Math.round(-3.5)` returns -3.</p>
            </emu-note>
            <emu-note>
              <p>When `x` is a Number, the value of `Math.round(x)` is not always the same as the value of `Math.floor(x + 0.5)`. When `x` is *-0*<sub>ð½</sub> or is less than *+0*<sub>ð½</sub> but greater than or equal to *-0.5*<sub>ð½</sub>, `Math.round(x)` returns *-0*<sub>ð½</sub>, but `Math.floor(x + 0.5)` returns *+0*<sub>ð½</sub>. `Math.round(x)` may also differ from the value of `Math.floor(x + 0.5)`because of internal rounding when computing `x + 0.5`.</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-sinh" type="numeric method">
            <h1>
              Number::sinh (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>ð½</sub>, _x_ is *-0*<sub>ð½</sub>, _x_ is *+&infin;*<sub>ð½</sub>, or _x_ is *-&infin;*<sub>ð½</sub>, return _x_.
              1. Return an implementation-approximated value representing the result of the hyperbolic sine of â(_x_).
            </emu-alg>

            <emu-note>
              <p>The value of `Math.sinh(x)` is the same as the value of `(Math.exp(x) - Math.exp(-x)) / 2`.</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-sqrt" type="numeric method">
            <h1>
              Number::sqrt (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>ð½</sub>, _x_ is *-0*<sub>ð½</sub>, or _x_ is *+&infin;*<sub>ð½</sub>, return _x_.
              1. If _x_ &lt; *+0*<sub>ð½</sub>, return *NaN*.
              1. Return an implementation-approximated value representing the result of the square root of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-tanh" type="numeric method">
            <h1>
              Number::tanh (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>ð½</sub>, or _x_ is *-0*<sub>ð½</sub>, return _x_.
              1. If _x_ is *+&infin;*<sub>ð½</sub>, return *1*<sub>ð½</sub>.
              1. If _x_ is *-&infin;*<sub>ð½</sub>, return *-1*<sub>ð½</sub>.
              1. Return an implementation-approximated value representing the result of the hyperbolic tangent of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-trunc" type="numeric method">
            <h1>
              Number::trunc (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>ð½</sub>, _x_ is *-0*<sub>ð½</sub>, _x_ is *+&infin;*<sub>ð½</sub>, or _x_ is *-&infin;*<sub>ð½</sub>, return _x_.
              1. If _x_ &lt; *1*<sub>ð½</sub> and _x_ &gt; *+0*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
              1. If _x_ &lt; *+0*<sub>ð½</sub> and _x_ &gt; *-1*<sub>ð½</sub>, return *-0*<sub>ð½</sub>.
              1. Return the integral Number nearest _x_ in the direction of *+0*<sub>ð½</sub>.
            </emu-alg>
          </emu-clause>
        </ins>
      </emu-clause>

      <emu-clause id="sec-ecmascript-language-types-bigint-type">
        <h1>The BigInt Type</h1>

        <ins class="block">
          <emu-clause id="sec-numeric-types-bigint-abs" type="numeric method">
            <h1>
              BigInt::abs (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return the BigInt value that represents abs(â(_x_)).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-acosh" type="numeric method">
            <h1>
              BigInt::acosh (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return an implementation-approximated BigInt value representing the result of the inverse hyperbolic cosine of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-asinh" type="numeric method">
            <h1>
              BigInt::asinh (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return an implementation-approximated BigInt value representing the result of the inverse hyperbolic sine of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-atanh" type="numeric method">
            <h1>
              BigInt::atanh (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return an implementation-approximated BigInt value representing the result of the inverse hyperbolic tangent of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-cosh" type="numeric method">
            <h1>
              BigInt::cosh (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return an implementation-approximated BigInt value representing the result of the hyperbolic cosine of â(_x_).
            </emu-alg>

            <emu-note>
              <p>The value of `Math.cosh(x)` is the same as the value of `(Math.exp(x) + Math.exp(-x)) / 2`.</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-cbrt" type="numeric method">
            <h1>
              BigInt::cbrt (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return an implementation-approximated BigInt value representing the result of the cube root of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-ceil" type="numeric method">
            <h1>
              BigInt::ceil (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return _x_.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-exp" type="numeric method">
            <h1>
              BigInt::exp (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return an implementation-approximated BigInt value representing the result of the exponential function of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-expm1" type="numeric method">
            <h1>
              BigInt::expm1 (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return an implementation-approximated BigInt value representing the result of subtracting 1 from the exponential function of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-floor" type="numeric method">
            <h1>
              BigInt::floor (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return _x_.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-log" type="numeric method">
            <h1>
              BigInt::log (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return an implementation-approximated BigInt value representing the result of the natural logarithm of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-log1p" type="numeric method">
            <h1>
              BigInt::log1p (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return an implementation-approximated BigInt value representing the result of the natural logarithm of 1 + â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-log10" type="numeric method">
            <h1>
              BigInt::log10 (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return an implementation-approximated BigInt value representing the result of the base 10 logarithm of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-log2" type="numeric method">
            <h1>
              BigInt::log2 (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return an implementation-approximated BigInt value representing the result of the base 2 logarithm of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-round" type="numeric method">
            <h1>
              BigInt::round (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return _x_.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-sign" type="numeric method">
            <h1>
              BigInt::sign (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *0*<sub>â¤</sub>, return _x_.
              1. If _x_ &lt; *0*<sub>â¤</sub>, return *-1*<sub>â¤</sub>.
              1. Return *1*<sub>â¤</sub>.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-sinh" type="numeric method">
            <h1>
              BigInt::sinh (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return an implementation-approximated BigInt value representing the result of the hyperbolic sine of â(_x_).
            </emu-alg>

            <emu-note>
              <p>The value of `Math.sinh(x)` is the same as the value of `(Math.exp(x) - Math.exp(-x)) / 2`.</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-sqrt" type="numeric method">
            <h1>
              BigInt::sqrt (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return an implementation-approximated BigInt value representing the result of the square root of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-tanh" type="numeric method">
            <h1>
              BigInt::tanh (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return an implementation-approximated BigInt value representing the result of the hyperbolic tangent of â(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-trunc" type="numeric method">
            <h1>
              BigInt::trunc (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return _x_.
            </emu-alg>
          </emu-clause>
        </ins>

    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>Numbers and Dates</h1>

  <emu-clause id="sec-math-object">
    <h1>The Math Object</h1>

    <emu-clause id="sec-function-properties-of-the-math-object">
      <h1>Function Properties of the Math Object</h1>

      <emu-note type=editor>
        <p>This section augments the <a
        href=https://tc39.es/ecma262/#sec-function-properties-of-the-math-object>original
        Function Properties of the Math Object clause</a>.</p>
      </emu-note>

      <emu-clause id="sec-math.abs">
        <h1>Math.abs ( _x_ )</h1>
        <p>Returns the absolute value of _x_; the result has the same magnitude as _x_ but has positive sign.</p>
        <p>When the `Math.abs` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, return *NaN*.
          1. If _n_ is *-0*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
          1. If _n_ is *-&infin;*<sub>ð½</sub>, return *+&infin;*<sub>ð½</sub>.
          1. If _n_ &lt; *+0*<sub>ð½</sub>, return -_n_.
          1. Return _n_.
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::abs(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.acosh">
        <h1>Math.acosh ( _x_ )</h1>
        <p>Returns the inverse hyperbolic cosine of _x_.</p>
        <p>When the `Math.acosh` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN* or _n_ is *+&infin;*<sub>ð½</sub>, return _n_.
          1. If _n_ is *1*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
          1. If _n_ &lt; *1*<sub>ð½</sub>, return *NaN*.
          1. Return an implementation-approximated value representing the result of the inverse hyperbolic cosine of â(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::acosh(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.asinh">
        <h1>Math.asinh ( _x_ )</h1>
        <p>Returns the inverse hyperbolic sine of _x_.</p>
        <p>When the `Math.asinh` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>ð½</sub>, _n_ is *-0*<sub>ð½</sub>, _n_ is *+&infin;*<sub>ð½</sub>, or _n_ is *-&infin;*<sub>ð½</sub>, return _n_.
          1. Return an implementation-approximated value representing the result of the inverse hyperbolic sine of â(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::asinh(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.atanh">
        <h1>Math.atanh ( _x_ )</h1>
        <p>Returns the inverse hyperbolic tangent of _x_.</p>
        <p>When the `Math.atanh` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>ð½</sub>, or _n_ is *-0*<sub>ð½</sub>, return _n_.
          1. If _n_ &gt; *1*<sub>ð½</sub> or _n_ &lt; *-1*<sub>ð½</sub>, return *NaN*.
          1. If _n_ is *1*<sub>ð½</sub>, return *+&infin;*<sub>ð½</sub>.
          1. If _n_ is *-1*<sub>ð½</sub>, return *-&infin;*<sub>ð½</sub>.
          1. Return an implementation-approximated value representing the result of the inverse hyperbolic tangent of â(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::atanh(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <ins class="block">

      <emu-clause id="sec-math.bighypot">
        <h1>Math.bigHypot ( ..._args_ )</h1>
        <p>Returns the square root of the sum of squares of its arguments as a BigInt. Its arguments must also all be BigInts.</p>
        <p>When the `Math.bigHypot` method is called with zero or more arguments which form the rest parameter ..._args_, the following steps are taken:</p>
        <emu-alg>
          1. Let _coerced_ be a new empty List.
          1. For each element _arg_ of _args_, do
            1. Let _n_ be ? ToBigInt(_arg_).
            1. Append _n_ to _coerced_.
          1. Let _onlyZero_ be *true*.
          1. For each element _bigInt_ of _coerced_, do
            1. If _bigInt_ is *NaN*, return *NaN*.
            1. If _bigInt_ is neither *+0*<sub>ð½</sub> nor *-0*<sub>â¤</sub>, set _onlyZero_ to *false*.
          1. If _onlyZero_ is *true*, return *0*<sub>â¤</sub>.
          1. Return an implementation-approximated value representing the square root of the sum of squares of the mathematical values of the elements of _coerced_.
        </emu-alg>
        <p>The *"length"* property of the `bigHypot` method is *2*<sub>ð½</sub>.</p>
        <emu-note>
          <p>Implementations should take care to avoid the loss of precision from overflows and underflows that are prone to occur in naive implementations when this function is called with two or more arguments.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.bigmax">
        <h1>Math.bigMax ( _firstArg_, ..._restArgs_ )</h1>
        <p>Given one or more arguments, calls ToBigInt on each of the arguments and returns the largest of the resulting values.</p>
        <p>When the `Math.bigMax` method is called with zero or more arguments which form the rest parameter ..._args_, the following steps are taken:</p>
        <emu-alg>
          1. Let _firstCoerced_ be ? ToBigInt(_firstArg_).
          1. Let _restCoerced_ be a new empty List.
          1. For each element _arg_ of _args_, do
            1. Let _n_ be ? ToBigInt(_arg_).
            1. Append _n_ to _restCoerced_.
          1. Let _highest_ be _firstCoerced_.
          1. For each element _bigInt_ of _restCoerced_, do
            1. If _bigInt_ &gt; _highest_, set _highest_ to _bigInt_.
          1. Return _highest_.
        </emu-alg>
        <emu-note>
          <p>The comparison of values to determine the largest value is done using the IsLessThan algorithm.</p>
          <p>Unlike <emu-xref href="#sec-math.max" title></emu-xref>, at least one argument is required. This is because there is no largest BigInt value, in contrast to Number values, which are bounded by *+&infin;*<sub>ð½</sub>.</p>
        </emu-note>
        <p>The *"length"* property of the `bigMax` method is *2*<sub>ð½</sub>.</p>
      </emu-clause>

      <emu-clause id="sec-math.bigmin">
        <h1>Math.bigMin ( _firstArg_, ..._restArgs_ )</h1>
        <p>Given zero or more arguments, calls ToBigInt on each of the arguments and returns the smallest of the resulting values.</p>
        <p>When the `Math.bigMin` method is called with zero or more arguments which form the rest parameter ..._args_, the following steps are taken:</p>
        <emu-alg>
          1. Let _firstCoerced_ be ? ToBigInt(_firstArg_).
          1. Let _restCoerced_ be a new empty List.
          1. For each element _arg_ of _args_, do
            1. Let _n_ be ? ToBigInt(_arg_).
            1. Append _n_ to _restCoerced_.
          1. Let _lowest_ be _firstCoerced_.
          1. For each element _bigInt_ of _restCoerced_, do
            1. If _bigInt_ &lt; _lowest_, set _lowest_ to _bigInt_.
          1. Return _lowest_.
        </emu-alg>
        <emu-note>
          <p>The comparison of values to determine the least value is done using the IsLessThan algorithm.</p>
          <p>Unlike <emu-xref href="#sec-math.min" title></emu-xref>, at least one argument is required. This is because there is no least BigInt value, in contrast to Number values, which are bounded by *-&infin;*<sub>ð½</sub>.</p>
        </emu-note>
        <p>The *"length"* property of the `bigMin` method is *2*<sub>ð½</sub>.</p>
      </emu-clause>

      </ins>

      <emu-clause id="sec-math.cbrt">
        <h1>Math.cbrt ( _x_ )</h1>
        <p>Returns the cube root of _x_.</p>
        <p>When the `Math.cbrt` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>ð½</sub>, _n_ is *-0*<sub>ð½</sub>, _n_ is *+&infin;*<sub>ð½</sub>, or _n_ is *-&infin;*<sub>ð½</sub>, return _n_.
          1. Return an implementation-approximated value representing the result of the cube root of â(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::cbrt(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.ceil">
        <h1>Math.ceil ( _x_ )</h1>
        <p>Returns the <del>smallest (closest to -&infin;) integral Number value</del><ins>lowest numeric value of the same type as _x_</ins> that is not less than _x_<ins> and whose mathematical value is an integer</ins>. If _x_ is already an integral Number <ins>or a BigInt</ins>, the result is _x_.</p>
        <p>When the `Math.ceil` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>ð½</sub>, _n_ is *-0*<sub>ð½</sub>, _n_ is *+&infin;*<sub>ð½</sub>, or _n_ is *-&infin;*<sub>ð½</sub>, return _n_.
          1. If _n_ &lt; *+0*<sub>ð½</sub> and _n_ &gt; *-1*<sub>ð½</sub>, return *-0*<sub>ð½</sub>.
          1. If _n_ is an integral Number, return _n_.
          1. Return the smallest (closest to -&infin;) integral Number value that is not less than _n_.
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::ceil(_n_).
        </emu-alg>
        </ins>
        <emu-note>
          <p>The value of `Math.ceil(x)` is the same as the value of `-Math.floor(-x)`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.cosh">
        <h1>Math.cosh ( _x_ )</h1>
        <p>Returns the hyperbolic cosine of _x_.</p>
        <p>When the `Math.cosh` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+&infin;*<sub>ð½</sub>, or _n_ is *-&infin;*<sub>ð½</sub>, return _n_.
          1. If _n_ is *+0*<sub>ð½</sub> or _n_ is *-0*<sub>ð½</sub>, return *1*<sub>ð½</sub>.
          1. Return an implementation-approximated value representing the result of the hyperbolic cosine of â(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::cosh(_n_).
        </emu-alg>
        </ins>
        <emu-note>
          <p>The value of `Math.cosh(x)` is the same as the value of `(Math.exp(x) + Math.exp(-x)) / 2`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.exp">
        <h1>Math.exp ( _x_ )</h1>
        <p>Returns the exponential function of _x_ (_e_ raised to the power of _x_, where _e_ is the base of the natural logarithms).</p>
        <p>When the `Math.exp` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN* or _n_ is *+&infin;*<sub>ð½</sub>, return _n_.
          1. If _n_ is *+0*<sub>ð½</sub> or _n_ is *-0*<sub>ð½</sub>, return *1*<sub>ð½</sub>.
          1. If _n_ is *-&infin;*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
          1. Return an implementation-approximated value representing the result of the exponential function of â(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::exp(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.expm1">
        <h1>Math.expm1 ( _x_ )</h1>
        <p>Returns the result of subtracting 1 from the exponential function of _x_ (_e_ raised to the power of _x_, where _e_ is the base of the natural logarithms). The result is computed in a way that is accurate even when the value of _x_ is close to 0.</p>
        <p>When the `Math.expm1` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>ð½</sub>, _n_ is *-0*<sub>ð½</sub>, or _n_ is *+&infin;*<sub>ð½</sub>, return _n_.
          1. If _n_ is *-&infin;*<sub>ð½</sub>, return *-1*<sub>ð½</sub>.
          1. Return an implementation-approximated value representing the result of subtracting 1 from the exponential function of â(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::expm1(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.floor">
        <h1>Math.floor ( _x_ )</h1>
        <p>Returns the <del>greatest (closest to +&infin;) integral Number value</del><ins>lowest numeric value of the same type as _x_</ins> that is not greater than _x_<ins> and whose mathematical value is an integer</ins>. If _x_ is already an integral Number <ins>or a BigInt</ins>, the result is _x_.</p>
        <p>When the `Math.floor` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>ð½</sub>, _n_ is *-0*<sub>ð½</sub>, _n_ is *+&infin;*<sub>ð½</sub>, or _n_ is *-&infin;*<sub>ð½</sub>, return _n_.
          1. If _n_ &lt; *+0*<sub>ð½</sub> and _n_ &gt; *-1*<sub>ð½</sub>, return *-0*<sub>ð½</sub>.
          1. If _n_ is an integral Number, return _n_.
          1. Return the greatest (closest to +&infin;) integral Number value that is not less than _n_.
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::floor(_n_).
        </emu-alg>
        </ins>
        <emu-note>
          <p>The value of `Math.floor(x)` is the same as the value of `-Math.ceil(-x)`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.log">
        <h1>Math.log ( _x_ )</h1>
        <p>Returns the natural logarithm of _x_.</p>
        <p>When the `Math.log` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN* or _n_ is *+&infin;*<sub>ð½</sub>, return _n_.
          1. If _n_ is *1*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
          1. If _n_ is *+0*<sub>ð½</sub> or _n_ is *-0*<sub>ð½</sub>, return *-&infin;*<sub>ð½</sub>.
          1. If _n_ &lt; *+0*<sub>ð½</sub>, return *NaN*.
          1. Return an implementation-approximated value representing the result of the natural logarithm of â(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::log(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.log1p">
        <h1>Math.log1p ( _x_ )</h1>
        <p>Returns the natural logarithm of 1 + _x_. The result is computed in a way that is accurate even when the value of x is close to zero.</p>
        <p>When the `Math.log1p` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>ð½</sub>, _n_ is *-0*<sub>ð½</sub>, or _n_ is *+&infin;*<sub>ð½</sub>, return _n_.
          1. If _n_ is *-1*<sub>ð½</sub>, return *-&infin;*<sub>ð½</sub>.
          1. If _n_ &lt; *-1*<sub>ð½</sub>, return *NaN*.
          1. Return an implementation-approximated value representing the result of the natural logarithm of 1 + â(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::log1p(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.log10">
        <h1>Math.log10 ( _x_ )</h1>
        <p>Returns the base 10 logarithm of _x_.</p>
        <p>When the `Math.log10` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN* or _n_ is *+&infin;*<sub>ð½</sub>, return _n_.
          1. If _n_ is *1*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
          1. If _n_ is *+0*<sub>ð½</sub> or _n_ is *-0*<sub>ð½</sub>, return *-&infin;*<sub>ð½</sub>.
          1. If _n_ &lt; *+0*<sub>ð½</sub>, return *NaN*.
          1. Return an implementation-approximated value representing the result of the base 10 logarithm of â(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::log10(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.log2">
        <h1>Math.log2 ( _x_ )</h1>
        <p>Returns the base 2 logarithm of _x_.</p>
        <p>When the `Math.log2` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN* or _n_ is *+&infin;*<sub>ð½</sub>, return _n_.
          1. If _n_ is *1*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
          1. If _n_ is *+0*<sub>ð½</sub> or _n_ is *-0*<sub>ð½</sub>, return *-&infin;*<sub>ð½</sub>.
          1. If _n_ &lt; *+0*<sub>ð½</sub>, return *NaN*.
          1. Return an implementation-approximated value representing the result of the base 2 logarithm of â(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::log2(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.pow">
        <h1>Math.pow ( _base_, _exponent_ )</h1>
        <p>When the `Math.pow` method is called with arguments _base_ and _exponent_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Set _base_ to ? ToNumber(_base_).
          1. Set _exponent_ to ? ToNumber(_exponent_).
          1. Return ! Number::exponentiate(_base_, _exponent_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Set _base_ to ? ToNumeric(_base_).
          1. Set _exponent_ to ? ToNumeric(_exponent_).
          1. If Type(_base_) is different from Type(_exponent_), throw a **TypeError** exception.
          1. Let _T_ be Type(_base_).
          1. Return ! _T_::exponentiate(_base_, _exponent_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.round">
        <h1>Math.round ( _x_ )</h1>
        <p>Returns the <del>Number value</del><ins>numeric value with the same type as _x_</ins> that is closest to _x_ and <del>is integral</del><ins>whose mathematical value is an integer</ins>. If <ins>_x_ is a Number and </ins>two integral Numbers are equally close to _x_, then the result is the Number value that is closer to +&infin;. If _x_ is already an integral Number <ins>or a BigInt</ins>, the result is _x_.</p>
        <p>When the `Math.round` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, *+&infin;*<sub>ð½</sub>, *-&infin;*<sub>ð½</sub>, or an integral Number, return _n_.
          1. If _n_ &lt; *0.5*<sub>ð½</sub> and _n_ &gt; *+0*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
          1. If _n_ &lt; *+0*<sub>ð½</sub> and _n_ &ge; *-0.5*<sub>ð½</sub>, return *-0*<sub>ð½</sub>.
          1. Return the integral Number closest to _n_, preferring the Number closer to +&infin; in the case of a tie.
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::round(_n_).
        </emu-alg>
        </ins>
        <emu-note>
          <p>`Math.round(3.5)` returns 4, but `Math.round(-3.5)` returns -3.</p>
        </emu-note>
        <emu-note>
          <p><ins>When `x` is a Number, t</ins><del>T</del>he value of `Math.round(x)` is not always the same as the value of `Math.floor(x + 0.5)`. When `x` is *-0*<sub>ð½</sub> or is less than *+0*<sub>ð½</sub> but greater than or equal to *-0.5*<sub>ð½</sub>, `Math.round(x)` returns *-0*<sub>ð½</sub>, but `Math.floor(x + 0.5)` returns *+0*<sub>ð½</sub>. `Math.round(x)` may also differ from the value of `Math.floor(x + 0.5)`because of internal rounding when computing `x + 0.5`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sign">
        <h1>Math.sign ( _x_ )</h1>
        <p>Returns the sign of _x_, indicating whether _x_ is positive, negative, or zero.</p>
        <p>When the `Math.sign` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>ð½</sub>, or _n_ is *-0*<sub>ð½</sub>, return _n_.
          1. If _n_ &lt; *+0*<sub>ð½</sub>, return *-1*<sub>ð½</sub>.
          1. Return *1*<sub>ð½</sub>.
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::sign(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.sinh">
        <h1>Math.sinh ( _x_ )</h1>
        <p>Returns the hyperbolic sine of _x_.</p>
        <p>When the `Math.sinh` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>ð½</sub>, _n_ is *-0*<sub>ð½</sub>, _n_ is *+&infin;*<sub>ð½</sub>, or _n_ is *-&infin;*<sub>ð½</sub>, return _n_.
          1. Return an implementation-approximated value representing the result of the hyperbolic sine of â(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::sinh(_n_).
        </emu-alg>
        </ins>
        <emu-note>
          <p>The value of `Math.sinh(x)` is the same as the value of `(Math.exp(x) - Math.exp(-x)) / 2`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sqrt">
        <h1>Math.sqrt ( _x_ )</h1>
        <p>Returns the square root of _x_.</p>
        <p>When the `Math.sqrt` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>ð½</sub>, _n_ is *-0*<sub>ð½</sub>, or _n_ is *+&infin;*<sub>ð½</sub>, return _n_.
          1. If _n_ &lt; *+0*<sub>ð½</sub>, return *NaN*.
          1. Return an implementation-approximated value representing the result of the square root of â(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::sqrt(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.tanh">
        <h1>Math.tanh ( _x_ )</h1>
        <p>Returns the hyperbolic tangent of _x_.</p>
        <p>When the `Math.tanh` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>ð½</sub>, or _n_ is *-0*<sub>ð½</sub>, return _n_.
          1. If _n_ is *+&infin;*<sub>ð½</sub>, return *1*<sub>ð½</sub>.
          1. If _n_ is *-&infin;*<sub>ð½</sub>, return *-1*<sub>ð½</sub>.
          1. Return an implementation-approximated value representing the result of the hyperbolic tangent of â(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::tanh(_n_).
        </emu-alg>
        </ins>
        <emu-note>
          <p>The value of `Math.tanh(x)` is the same as the value of `(Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x))`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.trunc">
        <h1>Math.trunc ( _x_ )</h1>
        <p>Returns the <del>Number value</del><ins>numeric value with the same type as _x_</ins> that is closest to _x_ and <del>is integral</del><ins>whose mathematical value is an integer</ins>. If <ins>_x_ is a Number and </ins>two integral Numbers are equally close to _x_, then the result is the Number value that is closer to +&infin;. If _x_ is already an integral Number <ins>or a BigInt</ins>, the result is _x_.</p>
        <p>Returns the integral part of the <del>number</del><ins>numeric value</ins> _x_, removing any fractional digits. If _x_ is already <ins>an </ins>integral<ins> Number or a BigInt</ins>, the result is _x_.</p>
        <p>When the `Math.trunc` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>ð½</sub>, _n_ is *-0*<sub>ð½</sub>, _n_ is *+&infin;*<sub>ð½</sub>, or _n_ is *-&infin;*<sub>ð½</sub>, return _n_.
          1. If _n_ &lt; *1*<sub>ð½</sub> and _n_ &gt; *+0*<sub>ð½</sub>, return *+0*<sub>ð½</sub>.
          1. If _n_ &lt; *+0*<sub>ð½</sub> and _n_ &gt; *-1*<sub>ð½</sub>, return *-0*<sub>ð½</sub>.
          1. Return the integral Number nearest _n_ in the direction of *+0*<sub>ð½</sub>.
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::trunc(_n_).
        </emu-alg>
        </ins>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
