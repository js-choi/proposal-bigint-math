<pre class=metadata>
title: ES BigInt Math (2021)
status: proposal
stage: 0
location: https://github.com/js-choi/proposal-bigint-math
copyright: false
contributors: J. S. Choi
</pre>
<script src=ecmarkup.js defer></script>
<link rel=stylesheet href=ecmarkup.css>

<emu-intro id=introduction>
  <h1>Introduction</h1>
  <p>This is the formal specification for a proposed extension
  of the `Math` JavaScript global object with BigInt operations.
  It modifies the original <a
  href=https://tc39.github.io/ecma262/>ECMAScript specification</a> with
  several new or revised clauses. See <a
  href=https://github.com/js-choi/proposal-bigint-math/blob/main/README.md>the proposal's
  explainer</a> for the proposal's background, motivation, and usage examples.</p>
</emu-intro>

<emu-clause id="sec-ecmascript-data-types-and-values" aoid="Type">
  <h1>ECMAScript Data Types and Values</h1>

  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript Language Types</h1>

    <emu-clause id="sec-numeric-types">
      <h1>Numeric Types</h1>

      <emu-note type=editor>
        <p>This section augments the <a
        href=https://tc39.es/ecma262/#sec-numeric-types>original
        Numeric Types clause</a>.</p>
      </emu-note>

      <p>ECMAScript has two built-in numeric types: Number and BigInt. In this specification, every numeric type _T_ contains a multiplicative identity value denoted _T_::unit. The specification types also have the following abstract operations, likewise denoted _T_::<i>op</i> for a given operation with specification name <i>op</i>. All argument types are _T_. The "Result" column shows the return type, along with an indication if it is possible for some invocations of the operation to return an abrupt completion.</p>
      <emu-table id="table-numeric-type-ops" caption="Numeric Type Operations">
        <table>
          <tbody>
          <tr>
            <th>
              Invocation Synopsis
            </th>
            <th>
              Example source
            </th>
            <th>
              Invoked by the Evaluation semantics of ...
            </th>
            <th>
              Result
            </th>
          </tr>

          <tr>
            <td>
              _T_::bitwiseOR(x,&nbsp;y)
            </td>
            <td>
              `x&nbsp;|&nbsp;y`
            </td>
            <td>
              <emu-xref href="#sec-binary-bitwise-operators" title></emu-xref>
            </td>
            <td>
              _T_
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::abs(x)</ins>
            </td>
            <td>
              <ins>`Math.abs(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.abs" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::ceil(x)</ins>
            </td>
            <td>
              <ins>`Math.ceil(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.ceil" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::cbrt(x)</ins>
            </td>
            <td>
              <ins>`Math.cbrt(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.cbrt" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::floor(x)</ins>
            </td>
            <td>
              <ins>`Math.floor(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.floor" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::log10(x)</ins>
            </td>
            <td>
              <ins>`Math.log10(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.log10" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::log2(x)</ins>
            </td>
            <td>
              <ins>`Math.log2(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.log2" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::round(x)</ins>
            </td>
            <td>
              <ins>`Math.round(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.round" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::sign(x)</ins>
            </td>
            <td>
              <ins>`Math.sign(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.sign" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::sqrt(x)</ins>
            </td>
            <td>
              <ins>`Math.sqrt(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.sqrt" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>

          <tr>
            <td>
              <ins>_T_::trunc(x)</ins>
            </td>
            <td>
              <ins>`Math.trunc(x)`</ins>
            </td>
            <td><ins><emu-xref href="#sec-math.trunc" title></emu-xref></ins>
            </td>
            <td>
              <ins>_T_</ins>
            </td>
          </tr>


          <tr>
            <td>
              _T_::toString(x)
            </td>
            <td>
              `String(x)`
            </td>
            <td>
              Many expressions and built-in functions, via <emu-xref href="#sec-tostring" title></emu-xref>
            </td>
            <td>
              String
            </td>

          </tr>
          </tbody>
        </table>
      </emu-table>

      <emu-clause id="sec-ecmascript-language-types-number-type">
        <h1>The Number Type</h1>

        <ins class="block">
          <emu-clause id="sec-numeric-types-number-abs" type="numeric method">
            <h1>
              Number::abs (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, return *NaN*.
              1. If _x_ is *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
              1. If _x_ is *-&infin;*<sub>𝔽</sub>, return *+&infin;*<sub>𝔽</sub>.
              1. If _x_ &lt; *+0*<sub>𝔽</sub>, return -_x_.
              1. Return _x_.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-ceil" type="numeric method">
            <h1>
              Number::ceil (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>𝔽</sub>, _x_ is *-0*<sub>𝔽</sub>, _x_ is *+&infin;*<sub>𝔽</sub>, or _x_ is *-&infin;*<sub>𝔽</sub>, return _x_.
              1. If _x_ &lt; *+0*<sub>𝔽</sub> and _x_ &gt; *-1*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.
              1. If _x_ is an integral Number, return _x_.
              1. Return the smallest (closest to -&infin;) integral Number value that is not less than _x_.
            </emu-alg>
            <emu-note>
              <p>The value of `Math.ceil(x)` is the same as the value of `-Math.floor(-x)`.</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-cbrt" type="numeric method">
            <h1>
              Number::cbrt (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>𝔽</sub>, _x_ is *-0*<sub>𝔽</sub>, _x_ is *+&infin;*<sub>𝔽</sub>, or _x_ is *-&infin;*<sub>𝔽</sub>, return _x_.
              1. Return an implementation-approximated value representing the result of the cube root of ℝ(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-floor" type="numeric method">
            <h1>
              Number::floor (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>𝔽</sub>, _x_ is *-0*<sub>𝔽</sub>, _x_ is *+&infin;*<sub>𝔽</sub>, or _x_ is *-&infin;*<sub>𝔽</sub>, return _x_.
              1. If _x_ &lt; *1*<sub>𝔽</sub> and _x_ &gt; *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
              1. If _x_ is an integral Number, return _x_.
              1. Return the greatest (closest to +&infin;) integral Number value that is not greater than _x_.
            </emu-alg>
            <emu-note>
              <p>The value of `Math.floor(x)` is the same as the value of `-Math.ceil(-x)`.</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-hypot" type="numeric method">
            <h1>
              Number::hypot (
                _x_: a BigInt,
                _rest_: a List,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Let _coerced_ be « _x_ ».
              1. For each element _arg_ of _rest_, do
                1. Let _n_ be ? ToNumber(_arg_).
                1. Append _n_ to _coerced_.
              1. Let _onlyZero_ be *true*.
              1. For each element _bigInt_ of _coerced_, do
                1. If _bigInt_ is *NaN*, return *NaN*.
                1. If _bigInt_ is neither *+0*<sub>𝔽</sub> nor *-0*<sub>ℤ</sub>, set _onlyZero_ to *false*.
              1. If _onlyZero_ is *true*, return *0*<sub>ℤ</sub>.
              1. Return an implementation-approximated value representing the square root of the sum of squares of the mathematical values of the elements of _coerced_.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-log10" type="numeric method">
            <h1>
              Number::log10 (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN* or _x_ is *+&infin;*<sub>𝔽</sub>, return _x_.
              1. If _x_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
              1. If _x_ is *+0*<sub>𝔽</sub> or _x_ is *-0*<sub>𝔽</sub>, return *-&infin;*<sub>𝔽</sub>.
              1. If _x_ &lt; *+0*<sub>𝔽</sub>, return *NaN*.
              1. Return an implementation-approximated value representing the result of the base-10 logarithm of ℝ(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-log2" type="numeric method">
            <h1>
              Number::log2 (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN* or _x_ is *+&infin;*<sub>𝔽</sub>, return _x_.
              1. If _x_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
              1. If _x_ is *+0*<sub>𝔽</sub> or _x_ is *-0*<sub>𝔽</sub>, return *-&infin;*<sub>𝔽</sub>.
              1. If _x_ &lt; *+0*<sub>𝔽</sub>, return *NaN*.
              1. Return an implementation-approximated value representing the result of the base-2 logarithm of ℝ(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-round" type="numeric method">
            <h1>
              Number::round (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, *+&infin;*<sub>𝔽</sub>, *-&infin;*<sub>𝔽</sub>, or an integral Number, return _x_.
              1. If _x_ &lt; *0.5*<sub>𝔽</sub> and _x_ &gt; *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
              1. If _x_ &lt; *+0*<sub>𝔽</sub> and _x_ &ge; *-0.5*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.
              1. Return the integral Number closest to _x_, preferring the Number closer to +&infin; in the case of a tie.
            </emu-alg>
            <emu-note>
              <p>`Math.round(3.5)` returns 4, but `Math.round(-3.5)` returns -3.</p>
            </emu-note>
            <emu-note>
              <p>When `x` is a Number, the value of `Math.round(x)` is not always the same as the value of `Math.floor(x + 0.5)`. When `x` is *-0*<sub>𝔽</sub> or is less than *+0*<sub>𝔽</sub> but greater than or equal to *-0.5*<sub>𝔽</sub>, `Math.round(x)` returns *-0*<sub>𝔽</sub>, but `Math.floor(x + 0.5)` returns *+0*<sub>𝔽</sub>. `Math.round(x)` may also differ from the value of `Math.floor(x + 0.5)`because of internal rounding when computing `x + 0.5`.</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-sqrt" type="numeric method">
            <h1>
              Number::sqrt (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>𝔽</sub>, _x_ is *-0*<sub>𝔽</sub>, or _x_ is *+&infin;*<sub>𝔽</sub>, return _x_.
              1. If _x_ &lt; *+0*<sub>𝔽</sub>, return *NaN*.
              1. Return an implementation-approximated value that represents the result of the square root of ℝ(_x_).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-number-trunc" type="numeric method">
            <h1>
              Number::trunc (
                _x_: a Number,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *NaN*, _x_ is *+0*<sub>𝔽</sub>, _x_ is *-0*<sub>𝔽</sub>, _x_ is *+&infin;*<sub>𝔽</sub>, or _x_ is *-&infin;*<sub>𝔽</sub>, return _x_.
              1. If _x_ &lt; *1*<sub>𝔽</sub> and _x_ &gt; *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
              1. If _x_ &lt; *+0*<sub>𝔽</sub> and _x_ &gt; *-1*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.
              1. Return the integral Number nearest _x_ in the direction of *+0*<sub>𝔽</sub>.
            </emu-alg>
          </emu-clause>
        </ins>
      </emu-clause>

      <emu-clause id="sec-ecmascript-language-types-bigint-type">
        <h1>The BigInt Type</h1>

        <ins class="block">
          <emu-clause id="sec-numeric-types-bigint-abs" type="numeric method">
            <h1>
              BigInt::abs (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return the BigInt value that represents abs(ℝ(_x_)).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-cbrt" type="numeric method">
            <h1>
              BigInt::cbrt (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ &lt; *0*<sub>ℤ</sub>, throw a *RangeError* exception.
              1. Let _root_ be the result of the cube root of ℝ(_x_).
              1. Return the BigInt value that represents _root_ rounded towards 0 to the next integer value.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-ceil" type="numeric method">
            <h1>
              BigInt::ceil (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return _x_.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-floor" type="numeric method">
            <h1>
              BigInt::floor (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return _x_.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-hypot" type="numeric method">
            <h1>
              BigInt::hypot (
                _x_: a BigInt,
                _rest_: a List,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Let _coerced_ be « _x_ ».
              1. For each element _arg_ of _rest_, do
                1. Let _n_ be ? ToBigInt(_arg_).
                1. Append _n_ to _coerced_.
              1. Let _hypot_ be the square root of the sum of squares of the mathematical values of the elements of _coerced_.
              1. Return the BigInt value that represents _hypot_ rounded towards 0 to the next integer value.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-log10" type="numeric method">
            <h1>
              BigInt::log10 (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ ≤ *0*<sub>ℤ</sub>, throw a *RangeError* exception.
              1. Let _logarithm_ be the result of the base-10 logarithm of ℝ(_x_).
              1. Return the BigInt value that represents _logarithm_ rounded towards 0 to the next integer value.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-log2" type="numeric method">
            <h1>
              BigInt::log2 (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ ≤ *0*<sub>ℤ</sub>, throw a *RangeError* exception.
              1. Let _logarithm_ be the result of the base-2 logarithm of ℝ(_x_).
              1. Return the BigInt value that represents _logarithm_ rounded towards 0 to the next integer value.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-round" type="numeric method">
            <h1>
              BigInt::round (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return _x_.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-sign" type="numeric method">
            <h1>
              BigInt::sign (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ is *0*<sub>ℤ</sub>, return _x_.
              1. If _x_ &lt; *0*<sub>ℤ</sub>, return *-1*<sub>ℤ</sub>.
              1. Return *1*<sub>ℤ</sub>.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-sqrt" type="numeric method">
            <h1>
              BigInt::sqrt (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. If _x_ &lt; *0*<sub>ℤ</sub>, throw a *RangeError* exception.
              1. Let _root_ be the result of the square root of ℝ(_x_).
              1. Return the BigInt value that represents _root_ rounded towards 0 to the next integer value.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-numeric-types-bigint-trunc" type="numeric method">
            <h1>
              BigInt::trunc (
                _x_: a BigInt,
              )
            </h1>
            <dl class="header">
            </dl>
            <emu-alg>
              1. Return _x_.
            </emu-alg>
          </emu-clause>
        </ins>

    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>Numbers and Dates</h1>

  <emu-clause id="sec-math-object">
    <h1>The Math Object</h1>

    <emu-clause id="sec-function-properties-of-the-math-object">
      <h1>Function Properties of the Math Object</h1>

      <emu-note type=editor>
        <p>This section augments the <a
        href=https://tc39.es/ecma262/#sec-function-properties-of-the-math-object>original
        Function Properties of the Math Object clause</a>.</p>
      </emu-note>

      <emu-clause id="sec-math.abs">
        <h1>Math.abs ( _x_ )</h1>
        <p>Returns the absolute value of _x_; the result has the same magnitude as _x_ but has positive sign.</p>
        <p>When the `Math.abs` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, return *NaN*.
          1. If _n_ is *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. If _n_ is *-&infin;*<sub>𝔽</sub>, return *+&infin;*<sub>𝔽</sub>.
          1. If _n_ &lt; *+0*<sub>𝔽</sub>, return -_n_.
          1. Return _n_.
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::abs(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.cbrt">
        <h1>Math.cbrt ( _x_ )</h1>
        <p>Returns the cube root of _x_.</p>
        <p>When the `Math.cbrt` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, _n_ is *-0*<sub>𝔽</sub>, _n_ is *+&infin;*<sub>𝔽</sub>, or _n_ is *-&infin;*<sub>𝔽</sub>, return _n_.
          1. Return an implementation-approximated value representing the result of the cube root of ℝ(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::cbrt(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.ceil">
        <h1>Math.ceil ( _x_ )</h1>
        <p>Returns the <del>smallest (closest to -&infin;) integral Number value</del><ins>lowest numeric value of the same type as _x_</ins> that is not less than _x_<ins> and whose mathematical value is an integer</ins>. If _x_ is already an integral Number <ins>or a BigInt</ins>, the result is _x_.</p>
        <p>When the `Math.ceil` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, _n_ is *-0*<sub>𝔽</sub>, _n_ is *+&infin;*<sub>𝔽</sub>, or _n_ is *-&infin;*<sub>𝔽</sub>, return _n_.
          1. If _n_ &lt; *+0*<sub>𝔽</sub> and _n_ &gt; *-1*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.
          1. If _n_ is an integral Number, return _n_.
          1. Return the smallest (closest to -&infin;) integral Number value that is not less than _n_.
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::ceil(_n_).
        </emu-alg>
        </ins>
        <emu-note>
          <p>The value of `Math.ceil(x)` is the same as the value of `-Math.floor(-x)`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.floor">
        <h1>Math.floor ( _x_ )</h1>
        <p>Returns the <del>greatest (closest to +&infin;) integral Number value</del><ins>lowest numeric value of the same type as _x_</ins> that is not greater than _x_<ins> and whose mathematical value is an integer</ins>. If _x_ is already an integral Number <ins>or a BigInt</ins>, the result is _x_.</p>
        <p>When the `Math.floor` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, _n_ is *-0*<sub>𝔽</sub>, _n_ is *+&infin;*<sub>𝔽</sub>, or _n_ is *-&infin;*<sub>𝔽</sub>, return _n_.
          1. If _n_ &lt; *+0*<sub>𝔽</sub> and _n_ &gt; *-1*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.
          1. If _n_ is an integral Number, return _n_.
          1. Return the greatest (closest to +&infin;) integral Number value that is not less than _n_.
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::floor(_n_).
        </emu-alg>
        </ins>
        <emu-note>
          <p>The value of `Math.floor(x)` is the same as the value of `-Math.ceil(-x)`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.hypot">
        <h1>Math.hypot ( ..._args_ )</h1>
        <p>Returns the square root of the sum of squares of its arguments.</p>
        <p>When the `Math.hypot` method is called with zero or more arguments which form the rest parameter ..._args_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _coerced_ be a new empty List.
          1. For each element _arg_ of _args_, do
            1. Let _n_ be ? ToNumber(_arg_).
            1. Append _n_ to _coerced_.
          1. For each element _number_ of _coerced_, do
            1. If _number_ is *+&infin;*<sub>𝔽</sub> or _number_ is *-&infin;*<sub>𝔽</sub>, return *+&infin;*<sub>𝔽</sub>.
          1. Let _onlyZero_ be *true*.
          1. For each element _number_ of _coerced_, do
            1. If _number_ is *NaN*, return *NaN*.
            1. If _number_ is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>, set _onlyZero_ to *false*.
          1. If _onlyZero_ is *true*, return *+0*<sub>𝔽</sub>.
          1. Return an implementation-approximated value representing the square root of the sum of squares of the mathematical values of the elements of _coerced_.
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. If _args_ is empty, then return *+0*<sub>𝔽</sub>.
          1. Let _x_ be _args_[0] and remove that element from _args_.
          1. Let _n_ be ? ToNumeric().
          1. Return _T_::hypot(_n_, _args_).
        </emu-alg>
        </ins>
        <p>The *"length"* property of the `hypot` method is *2*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>Implementations should take care to avoid the loss of precision from overflows and underflows that are prone to occur in naive implementations when this function is called with two or more arguments.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.log10">
        <h1>Math.log10 ( _x_ )</h1>
        <p>Returns the base 10 logarithm of _x_.</p>
        <p>When the `Math.log10` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN* or _n_ is *+&infin;*<sub>𝔽</sub>, return _n_.
          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. If _n_ is *+0*<sub>𝔽</sub> or _n_ is *-0*<sub>𝔽</sub>, return *-&infin;*<sub>𝔽</sub>.
          1. If _n_ &lt; *+0*<sub>𝔽</sub>, return *NaN*.
          1. Return an implementation-approximated value representing the result of the base 10 logarithm of ℝ(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::log10(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.log2">
        <h1>Math.log2 ( _x_ )</h1>
        <p>Returns the base 2 logarithm of _x_.</p>
        <p>When the `Math.log2` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN* or _n_ is *+&infin;*<sub>𝔽</sub>, return _n_.
          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. If _n_ is *+0*<sub>𝔽</sub> or _n_ is *-0*<sub>𝔽</sub>, return *-&infin;*<sub>𝔽</sub>.
          1. If _n_ &lt; *+0*<sub>𝔽</sub>, return *NaN*.
          1. Return an implementation-approximated value representing the result of the base 2 logarithm of ℝ(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::log2(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.max">
        <h1>Math.max ( ..._args_ )</h1>
        <p>Given zero or more arguments, calls <del>ToNumber</del><ins>ToNumeric</ins> on each of the arguments and returns the largest of the resulting values. <ins>When multiple arguments share the same mathematical value, then the latest argument is returned.</ins></p>
        <p>When the `Math.max` method is called with zero or more arguments which form the rest parameter ..._args_, the following steps are taken:</p>
        <emu-alg>
          1. Let _coerced_ be a new empty List.
          1. For each element _arg_ of _args_, do
            1. Let _n_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_arg_).
            1. Append _n_ to _coerced_.
          1. Let _highest_ be *-&infin;*<sub>𝔽</sub>.
          1. For each element _number_ of _coerced_, do
            1. If _number_ is *NaN*, return *NaN*.
            1. If _number_ is *+0*<sub>𝔽</sub> and _highest_ is *-0*<sub>𝔽</sub>, set _highest_ to *+0*<sub>𝔽</sub>.
            1. If <del>_number_ &gt; _highest_</del><ins>ℝ(_number_) ≥ ℝ(_highest_)</ins>, set _highest_ to _number_.
          1. Return _highest_.
        </emu-alg>
        <emu-note>
          <p>The comparison of values to determine the largest value is done using the IsLessThan algorithm except that *+0*<sub>𝔽</sub> is considered to be larger than *-0*<sub>𝔽</sub>.</p>
        </emu-note>
        <p>The *"length"* property of the `max` method is *2*<sub>𝔽</sub>.</p>
      </emu-clause>

      <emu-clause id="sec-math.min">
        <h1>Math.min ( ..._args_ )</h1>
        <p>Given zero or more arguments, calls <del>ToNumber</del><ins>ToNumeric</ins> on each of the arguments and returns the smallest of the resulting values. <ins>When multiple arguments share the same mathematical value, then the earliest argument is returned.</ins></p>
        <p>When the `Math.min` method is called with zero or more arguments which form the rest parameter ..._args_, the following steps are taken:</p>
        <emu-alg>
          1. Let _coerced_ be a new empty List.
          1. For each element _arg_ of _args_, do
            1. Let _n_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_arg_).
            1. Append _n_ to _coerced_.
          1. Let _lowest_ be *+&infin;*<sub>𝔽</sub>.
          1. For each element _number_ of _coerced_, do
            1. If _number_ is *NaN*, return *NaN*.
            1. If _number_ is *-0*<sub>𝔽</sub> and _lowest_ is *+0*<sub>𝔽</sub>, set _lowest_ to *-0*<sub>𝔽</sub>.
            1. If <del>_number_ &lt; _lowest_</del><ins>ℝ(_number_) &lt; ℝ(_lowest_)</ins>, set _lowest_ to _number_.
          1. Return _lowest_.
        </emu-alg>
        <emu-note>
          <p>The comparison of values to determine the largest value is done using the IsLessThan algorithm except that *+0*<sub>𝔽</sub> is considered to be larger than *-0*<sub>𝔽</sub>.</p>
        </emu-note>
        <p>The *"length"* property of the `min` method is *2*<sub>𝔽</sub>.</p>
      </emu-clause>

      <emu-clause id="sec-math.pow">
        <h1>Math.pow ( _base_, _exponent_ )</h1>
        <p>When the `Math.pow` method is called with arguments _base_ and _exponent_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Set _base_ to ? ToNumber(_base_).
          1. Set _exponent_ to ? ToNumber(_exponent_).
          1. Return ! Number::exponentiate(_base_, _exponent_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Set _base_ to ? ToNumeric(_base_).
          1. Set _exponent_ to ? ToNumeric(_exponent_).
          1. If Type(_base_) is different from Type(_exponent_), throw a **TypeError** exception.
          1. Let _T_ be Type(_base_).
          1. Return ! _T_::exponentiate(_base_, _exponent_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.round">
        <h1>Math.round ( _x_ )</h1>
        <p>Returns the <del>Number value</del><ins>numeric value with the same type as _x_</ins> that is closest to _x_ and <del>is integral</del><ins>whose mathematical value is an integer</ins>. If <ins>_x_ is a Number and </ins>two integral Numbers are equally close to _x_, then the result is the Number value that is closer to +&infin;. If _x_ is already an integral Number <ins>or a BigInt</ins>, the result is _x_.</p>
        <p>When the `Math.round` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, *+&infin;*<sub>𝔽</sub>, *-&infin;*<sub>𝔽</sub>, or an integral Number, return _n_.
          1. If _n_ &lt; *0.5*<sub>𝔽</sub> and _n_ &gt; *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. If _n_ &lt; *+0*<sub>𝔽</sub> and _n_ &ge; *-0.5*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.
          1. Return the integral Number closest to _n_, preferring the Number closer to +&infin; in the case of a tie.
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::round(_n_).
        </emu-alg>
        </ins>
        <emu-note>
          <p>`Math.round(3.5)` returns 4, but `Math.round(-3.5)` returns -3.</p>
        </emu-note>
        <emu-note>
          <p><ins>When `x` is a Number, t</ins><del>T</del>he value of `Math.round(x)` is not always the same as the value of `Math.floor(x + 0.5)`. When `x` is *-0*<sub>𝔽</sub> or is less than *+0*<sub>𝔽</sub> but greater than or equal to *-0.5*<sub>𝔽</sub>, `Math.round(x)` returns *-0*<sub>𝔽</sub>, but `Math.floor(x + 0.5)` returns *+0*<sub>𝔽</sub>. `Math.round(x)` may also differ from the value of `Math.floor(x + 0.5)`because of internal rounding when computing `x + 0.5`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sign">
        <h1>Math.sign ( _x_ )</h1>
        <p>Returns the sign of _x_, indicating whether _x_ is positive, negative, or zero.</p>
        <p>When the `Math.sign` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, or _n_ is *-0*<sub>𝔽</sub>, return _n_.
          1. If _n_ &lt; *+0*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.
          1. Return *1*<sub>𝔽</sub>.
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::sign(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.sqrt">
        <h1>Math.sqrt ( _x_ )</h1>
        <p>Returns the square root of _x_.</p>
        <p>When the `Math.sqrt` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, _n_ is *-0*<sub>𝔽</sub>, or _n_ is *+&infin;*<sub>𝔽</sub>, return _n_.
          1. If _n_ &lt; *+0*<sub>𝔽</sub>, return *NaN*.
          1. Return an implementation-approximated value representing the result of the square root of ℝ(_n_).
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::sqrt(_n_).
        </emu-alg>
        </ins>
      </emu-clause>

      <emu-clause id="sec-math.trunc">
        <h1>Math.trunc ( _x_ )</h1>
        <p>Returns the <del>Number value</del><ins>numeric value with the same type as _x_</ins> that is closest to _x_ and <del>is integral</del><ins>whose mathematical value is an integer</ins>. If <ins>_x_ is a Number and </ins>two integral Numbers are equally close to _x_, then the result is the Number value that is closer to +&infin;. If _x_ is already an integral Number <ins>or a BigInt</ins>, the result is _x_.</p>
        <p>Returns the integral part of the <del>number</del><ins>numeric value</ins> _x_, removing any fractional digits. If _x_ is already <ins>an </ins>integral<ins> Number or a BigInt</ins>, the result is _x_.</p>
        <p>When the `Math.trunc` method is called with argument _x_, the following steps are taken:</p>
        <del class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ is *+0*<sub>𝔽</sub>, _n_ is *-0*<sub>𝔽</sub>, _n_ is *+&infin;*<sub>𝔽</sub>, or _n_ is *-&infin;*<sub>𝔽</sub>, return _n_.
          1. If _n_ &lt; *1*<sub>𝔽</sub> and _n_ &gt; *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. If _n_ &lt; *+0*<sub>𝔽</sub> and _n_ &gt; *-1*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.
          1. Return the integral Number nearest _n_ in the direction of *+0*<sub>𝔽</sub>.
        </emu-alg>
        </del>
        <ins class="block">
        <emu-alg>
          1. Let _n_ be ? ToNumeric(_x_).
          1. Let _T_ be Type(_n_).
          1. Return _T_::trunc(_n_).
        </emu-alg>
        </ins>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
